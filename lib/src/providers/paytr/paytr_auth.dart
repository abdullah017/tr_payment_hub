import 'dart:convert';
import 'package:crypto/crypto.dart';

import '../../utils/security_utils.dart';

/// Handles PayTR token generation and authentication.
///
/// PayTR uses HMAC-SHA256 signatures with Base64 encoding for
/// authentication. Each API operation requires a specific token
/// generated from the relevant parameters.
///
/// ## Token Generation
///
/// PayTR tokens are generated by:
/// 1. Concatenating specific fields in a defined order
/// 2. Appending the merchant salt
/// 3. Computing HMAC-SHA256 using the merchant key
/// 4. Base64 encoding the result
///
/// ## Available Token Types
///
/// * [generateIframeToken] - iFrame payment initialization
/// * [generatePaymentToken] - Direct API payments
/// * [generateRefundToken] - Refund processing
/// * [generateStatusToken] - Payment status queries
/// * [generateInstallmentToken] - Installment queries
///
/// ## Callback Verification
///
/// PayTR sends callback notifications after payment completion.
/// Use [verifyCallbackHash] to validate these callbacks:
///
/// ```dart
/// final isValid = auth.verifyCallbackHash(
///   merchantOid: 'ORDER_123',
///   status: 'success',
///   totalAmount: '10000',
///   receivedHash: callbackData['hash'],
/// );
/// ```
///
/// ## Security Notes
///
/// * Merchant credentials must never be exposed to clients
/// * Callback verification uses timing-safe comparison
/// * All tokens are request-specific and cannot be reused
///
/// ## PayTR API Reference
///
/// See [PayTR documentation](https://dev.paytr.com/) for API details.
class PayTRAuth {
  /// Creates a new [PayTRAuth] instance.
  ///
  /// [merchantId] - The merchant ID from PayTR dashboard
  /// [merchantKey] - The merchant API key
  /// [merchantSalt] - The merchant salt for hash generation
  PayTRAuth({
    required this.merchantId,
    required this.merchantKey,
    required this.merchantSalt,
  });

  /// The merchant ID assigned by PayTR.
  final String merchantId;

  /// The merchant API key for HMAC signature generation.
  final String merchantKey;

  /// The merchant salt for additional security.
  final String merchantSalt;

  /// iFrame API için token oluştur
  /// Hash string sırası: merchant_id + user_ip + merchant_oid + email + payment_amount + user_basket + no_installment + max_installment + currency + test_mode
  String generateIframeToken({
    required String userIp,
    required String merchantOid,
    required String email,
    required String paymentAmount,
    required String userBasket,
    required String noInstallment,
    required String maxInstallment,
    required String currency,
    required String testMode,
  }) {
    final hashString =
        '$merchantId$userIp$merchantOid$email$paymentAmount$userBasket$noInstallment$maxInstallment$currency$testMode';

    return _generateToken(hashString);
  }

  /// Direct API için paytr_token oluştur
  String generatePaymentToken({
    required String userIp,
    required String merchantOid,
    required String email,
    required String paymentAmount,
    required String paymentType,
    required String installmentCount,
    required String currency,
    required String testMode,
    required String non3d,
  }) {
    final hashString =
        '$merchantId$userIp$merchantOid$email$paymentAmount$paymentType$installmentCount$currency$testMode$non3d';
    return _generateToken(hashString);
  }

  /// Refund için token oluştur
  String generateRefundToken({
    required String merchantOid,
    required String returnAmount,
  }) {
    final hashString = '$merchantId$merchantOid$returnAmount';
    return _generateToken(hashString);
  }

  /// Status sorgusu için token oluştur
  String generateStatusToken({required String merchantOid}) {
    final hashString = '$merchantId$merchantOid';
    return _generateToken(hashString);
  }

  /// Taksit oranları sorgusu için token oluştur
  String generateInstallmentToken({required String requestId}) {
    final hashString = '$merchantId$requestId';
    return _generateToken(hashString);
  }

  /// Callback hash doğrulama
  ///
  /// Uses constant-time comparison to prevent timing attacks.
  /// This is critical for security - standard string comparison
  /// can leak information through timing differences.
  bool verifyCallbackHash({
    required String merchantOid,
    required String status,
    required String totalAmount,
    required String receivedHash,
  }) {
    final hashString = '$merchantOid$merchantSalt$status$totalAmount';
    final calculatedHash = _generateToken(hashString);
    // Use constant-time comparison to prevent timing attacks
    return SecurityUtils.constantTimeEquals(calculatedHash, receivedHash);
  }

  /// Token oluşturma (HMAC-SHA256 + Base64)
  String _generateToken(String hashString) {
    final dataWithSalt = hashString + merchantSalt;
    final key = utf8.encode(merchantKey);
    final data = utf8.encode(dataWithSalt);

    final hmac = Hmac(sha256, key);
    final digest = hmac.convert(data);

    return base64.encode(digest.bytes);
  }
}
